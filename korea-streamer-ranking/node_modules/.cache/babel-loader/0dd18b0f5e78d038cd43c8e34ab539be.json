{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NetworkEventManager = void 0;\n/**\n * @internal\n *\n * Helper class to track network events by request ID\n */\n\nclass NetworkEventManager {\n  constructor() {\n    /*\n     * There are four possible orders of events:\n     *  A. `_onRequestWillBeSent`\n     *  B. `_onRequestWillBeSent`, `_onRequestPaused`\n     *  C. `_onRequestPaused`, `_onRequestWillBeSent`\n     *  D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,\n     *     `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`\n     *     (see crbug.com/1196004)\n     *\n     * For `_onRequest` we need the event from `_onRequestWillBeSent` and\n     * optionally the `interceptionId` from `_onRequestPaused`.\n     *\n     * If request interception is disabled, call `_onRequest` once per call to\n     * `_onRequestWillBeSent`.\n     * If request interception is enabled, call `_onRequest` once per call to\n     * `_onRequestPaused` (once per `interceptionId`).\n     *\n     * Events are stored to allow for subsequent events to call `_onRequest`.\n     *\n     * Note that (chains of) redirect requests have the same `requestId` (!) as\n     * the original request. We have to anticipate series of events like these:\n     *  A. `_onRequestWillBeSent`,\n     *     `_onRequestWillBeSent`, ...\n     *  B. `_onRequestWillBeSent`, `_onRequestPaused`,\n     *     `_onRequestWillBeSent`, `_onRequestPaused`, ...\n     *  C. `_onRequestWillBeSent`, `_onRequestPaused`,\n     *     `_onRequestPaused`, `_onRequestWillBeSent`, ...\n     *  D. `_onRequestPaused`, `_onRequestWillBeSent`,\n     *     `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,\n     *     `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`, ...\n     *     (see crbug.com/1196004)\n     */\n    this._requestWillBeSentMap = new Map();\n    this._requestPausedMap = new Map();\n    this._httpRequestsMap = new Map();\n    /*\n     * The below maps are used to reconcile Network.responseReceivedExtraInfo\n     * events with their corresponding request. Each response and redirect\n     * response gets an ExtraInfo event, and we don't know which will come first.\n     * This means that we have to store a Response or an ExtraInfo for each\n     * response, and emit the event when we get both of them. In addition, to\n     * handle redirects, we have to make them Arrays to represent the chain of\n     * events.\n     */\n\n    this._responseReceivedExtraInfoMap = new Map();\n    this._queuedRedirectInfoMap = new Map();\n    this._queuedEventGroupMap = new Map();\n  }\n\n  forget(networkRequestId) {\n    this._requestWillBeSentMap.delete(networkRequestId);\n\n    this._requestPausedMap.delete(networkRequestId);\n\n    this._queuedEventGroupMap.delete(networkRequestId);\n\n    this._queuedRedirectInfoMap.delete(networkRequestId);\n\n    this._responseReceivedExtraInfoMap.delete(networkRequestId);\n  }\n\n  responseExtraInfo(networkRequestId) {\n    if (!this._responseReceivedExtraInfoMap.has(networkRequestId)) {\n      this._responseReceivedExtraInfoMap.set(networkRequestId, []);\n    }\n\n    return this._responseReceivedExtraInfoMap.get(networkRequestId);\n  }\n\n  queuedRedirectInfo(fetchRequestId) {\n    if (!this._queuedRedirectInfoMap.has(fetchRequestId)) {\n      this._queuedRedirectInfoMap.set(fetchRequestId, []);\n    }\n\n    return this._queuedRedirectInfoMap.get(fetchRequestId);\n  }\n\n  queueRedirectInfo(fetchRequestId, redirectInfo) {\n    this.queuedRedirectInfo(fetchRequestId).push(redirectInfo);\n  }\n\n  takeQueuedRedirectInfo(fetchRequestId) {\n    return this.queuedRedirectInfo(fetchRequestId).shift();\n  }\n\n  numRequestsInProgress() {\n    return [...this._httpRequestsMap].filter(_ref => {\n      let [, request] = _ref;\n      return !request.response();\n    }).length;\n  }\n\n  storeRequestWillBeSent(networkRequestId, event) {\n    this._requestWillBeSentMap.set(networkRequestId, event);\n  }\n\n  getRequestWillBeSent(networkRequestId) {\n    return this._requestWillBeSentMap.get(networkRequestId);\n  }\n\n  forgetRequestWillBeSent(networkRequestId) {\n    this._requestWillBeSentMap.delete(networkRequestId);\n  }\n\n  getRequestPaused(networkRequestId) {\n    return this._requestPausedMap.get(networkRequestId);\n  }\n\n  forgetRequestPaused(networkRequestId) {\n    this._requestPausedMap.delete(networkRequestId);\n  }\n\n  storeRequestPaused(networkRequestId, event) {\n    this._requestPausedMap.set(networkRequestId, event);\n  }\n\n  getRequest(networkRequestId) {\n    return this._httpRequestsMap.get(networkRequestId);\n  }\n\n  storeRequest(networkRequestId, request) {\n    this._httpRequestsMap.set(networkRequestId, request);\n  }\n\n  forgetRequest(networkRequestId) {\n    this._httpRequestsMap.delete(networkRequestId);\n  }\n\n  getQueuedEventGroup(networkRequestId) {\n    return this._queuedEventGroupMap.get(networkRequestId);\n  }\n\n  queueEventGroup(networkRequestId, event) {\n    this._queuedEventGroupMap.set(networkRequestId, event);\n  }\n\n  forgetQueuedEventGroup(networkRequestId) {\n    this._queuedEventGroupMap.delete(networkRequestId);\n  }\n\n}\n\nexports.NetworkEventManager = NetworkEventManager;","map":{"version":3,"mappings":"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","names":["NetworkEventManager","constructor","Map","forget","networkRequestId","_requestWillBeSentMap","delete","_requestPausedMap","_queuedEventGroupMap","_queuedRedirectInfoMap","_responseReceivedExtraInfoMap","responseExtraInfo","has","set","get","queuedRedirectInfo","fetchRequestId","queueRedirectInfo","redirectInfo","push","takeQueuedRedirectInfo","shift","numRequestsInProgress","_httpRequestsMap","filter","request","response","length","storeRequestWillBeSent","event","getRequestWillBeSent","forgetRequestWillBeSent","getRequestPaused","forgetRequestPaused","storeRequestPaused","getRequest","storeRequest","forgetRequest","getQueuedEventGroup","queueEventGroup","forgetQueuedEventGroup","exports"],"sources":["../../../../src/common/NetworkEventManager.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}